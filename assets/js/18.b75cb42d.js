(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{401:function(a,e,s){"use strict";s.r(e);var o=s(42),t=Object(o.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"_14-stack-e-heap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-stack-e-heap"}},[a._v("#")]),a._v(" 14 - Stack e Heap")]),a._v(" "),s("p",[a._v("A memória que um programa usa é normalmente dividida em algumas áreas diferentes, chamadas segmentos:")]),a._v(" "),s("ul",[s("li",[a._v("O segmento de código (também chamado de segmento de texto), onde o programa compilado fica na memória. O segmento de código normalmente é somente leitura.")]),a._v(" "),s("li",[a._v("O segmento bss (também chamado de segmento de dados não inicializado), onde variáveis globais e estáticas inicializadas com zero são armazenadas.")]),a._v(" "),s("li",[a._v("O segmento de dados (também chamado de segmento de dados inicializado), onde as variáveis globais e estáticas inicializadas são armazenadas.")]),a._v(" "),s("li",[a._v("O heap, de onde variáveis alocadas dinamicamente são alocadas.")]),a._v(" "),s("li",[a._v("A stack(pilha) de chamadas, onde são armazenados os parâmetros da função, variáveis locais e outras informações relacionadas à função.\nNesta lição, focaremos principalmente a heap e a stack, pois é aí que a maioria das coisas interessantes ocorre.")])]),a._v(" "),s("p",[a._v('O segmento de heap (também conhecido como "armazenamento gratuito") controla a memória usada para alocação dinâmica de memória. Utilizamos ela na seção passada:')]),a._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("div",{staticClass:"highlight-lines"},[s("br"),s("br"),s("br"),s("br"),s("br"),s("br")]),s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("ponteiro "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ptr is assigned 4 bytes in the heap")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v("vetor "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// array is assigned 40 bytes in the heap")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("delete")]),a._v(" ponteiro"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("delete")]),a._v(" vetor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v('Quando uma variável alocada dinamicamente é excluída, a memória é "retornada" para o heap e pode ser reatribuída à medida que futuras solicitações de alocação forem recebidas. Lembre-se de que excluir um ponteiro não exclui a variável, apenas retorna a memória no endereço associado ao sistema operacional.')]),a._v(" "),s("p",[a._v("A stack tem vantagens e desvantagens:")]),a._v(" "),s("ul",[s("li",[a._v("A alocação de memória no heap é comparativamente lenta.")]),a._v(" "),s("li",[a._v("A memória alocada permanece alocada até que seja desalocada especificamente (cuidado com vazamentos de memória) ou o aplicativo termina (nesse ponto, o SO deve limpá-la).")]),a._v(" "),s("li",[a._v("A memória alocada dinamicamente deve ser acessada por meio de um ponteiro. Desreferenciar um ponteiro é mais lento do que acessar diretamente uma variável.\nComo o heap é um grande pool de memória, matrizes, estruturas ou classes grandes podem ser alocadas aqui.")])]),a._v(" "),s("h1",{attrs:{id:"a-stack-de-chamadas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-stack-de-chamadas"}},[a._v("#")]),a._v(" A stack de chamadas")]),a._v(" "),s("p",[a._v('A stack de chamadas (geralmente chamada de "a pilha") tem um papel muito mais interessante a desempenhar. A pilha de chamadas controla todas as funções ativas (aquelas que foram chamadas, mas ainda não foram finalizadas) desde o início do programa até o ponto de execução atual e lida com a alocação de todos os parâmetros de função e variáveis locais.')]),a._v(" "),s("p",[a._v("A pilha de chamadas é implementada como uma estrutura de dados da pilha. Portanto, antes de podermos falar sobre como a pilha de chamadas funciona, precisamos entender o que é uma estrutura de dados da pilha.")]),a._v(" "),s("p",[a._v("Uma estrutura de dados é um mecanismo de programação para organizar dados, para que possam ser usados com eficiência. Você já viu vários tipos de estruturas de dados, como matrizes e estruturas. Ambas as estruturas de dados fornecem mecanismos para armazenar dados e acessar esses dados de maneira eficiente. Existem muitas estruturas de dados adicionais que são comumente usadas em programação, algumas das quais são implementadas na biblioteca padrão e uma pilha é uma delas.")]),a._v(" "),s("h1",{attrs:{id:"funcionamento-de-uma-pilha"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#funcionamento-de-uma-pilha"}},[a._v("#")]),a._v(" Funcionamento de uma Pilha")]),a._v(" "),s("ul",[s("li",[a._v("Olhe para o item superior da pilha(geralmente feito através de uma função chamada top(), mas às vezes chamada de peek())")]),a._v(" "),s("li",[a._v("Retire o item principal da pilha(feito por meio de uma função chamada pop())")]),a._v(" "),s("li",[a._v("Coloque um novo item no topo da pilha(feito através de uma função chamada push())")])]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("Pilha")]),a._v(" "),s("th",[a._v("Saida")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("Stack")]),a._v(" "),s("td",[a._v("Vazia")])]),a._v(" "),s("tr",[s("td",[a._v("Push")]),a._v(" "),s("td",[a._v("1")])]),a._v(" "),s("tr",[s("td",[a._v("Stack")]),a._v(" "),s("td",[a._v("1")])]),a._v(" "),s("tr",[s("td",[a._v("Push")]),a._v(" "),s("td",[a._v("2")])]),a._v(" "),s("tr",[s("td",[a._v("Stack")]),a._v(" "),s("td",[a._v("1 2")])]),a._v(" "),s("tr",[s("td",[a._v("Push")]),a._v(" "),s("td",[a._v("3")])]),a._v(" "),s("tr",[s("td",[a._v("Stack")]),a._v(" "),s("td",[a._v("1 2 3")])]),a._v(" "),s("tr",[s("td",[a._v("Pop")]),a._v(" "),s("td")]),a._v(" "),s("tr",[s("td",[a._v("Push")]),a._v(" "),s("td",[a._v("1 2")])]),a._v(" "),s("tr",[s("td",[a._v("Pop")]),a._v(" "),s("td")]),a._v(" "),s("tr",[s("td",[a._v("Stack")]),a._v(" "),s("td",[a._v("1")])])])]),a._v(" "),s("h1",{attrs:{id:"o-segmento-da-stack-de-chamadas"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#o-segmento-da-stack-de-chamadas"}},[a._v("#")]),a._v(" O segmento da stack de chamadas")]),a._v(" "),s("p",[a._v("O segmento da pilha de chamadas mantém a memória usada para a pilha de chamadas. Quando a aplicação é iniciada, a função main () é pressionada na pilha de chamadas pelo sistema operacional. Então o programa começa a executar.")]),a._v(" "),s("p",[a._v("Quando uma chamada de função é encontrada, a função é enviada para a pilha de chamadas. Quando a função atual termina, essa função é retirada da pilha de chamadas. Assim, observando as funções pressionadas na pilha de chamadas, podemos ver todas as funções que foram chamadas para chegar ao ponto de execução atual.")]),a._v(" "),s("p",[a._v('Nossa analogia da caixa de correio acima é bastante semelhante à maneira como a pilha de chamadas funciona. A própria pilha é um pedaço de tamanho fixo de endereços de memória. As caixas de correio são endereços de memória e os "itens" que estamos empurrando e popping na pilha são chamados de quadros de pilha. Um quadro de pilha controla todos os dados associados a uma chamada de função. Falaremos mais sobre os quadros de pilha em breve. O "marcador" é um registro (um pequeno pedaço de memória na CPU) conhecido como ponteiro da pilha (às vezes abreviado como "SP"). O ponteiro da pilha controla onde está atualmente a parte superior da pilha de chamadas.')]),a._v(" "),s("p",[a._v("A única diferença entre nossa pilha hipotética de caixa de correio e a pilha de chamadas é que, quando retiramos um item da pilha de chamadas, não precisamos apagar a memória (o equivalente a esvaziar a caixa de correio). Podemos apenas deixá-lo sobrescrito pelo próximo item enviado para esse pedaço de memória. Como o ponteiro da pilha estará abaixo desse local da memória, sabemos que o local da memória não está na pilha.")]),a._v(" "),s("h1",{attrs:{id:"a-pilha-de-chamadas-em-acao"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-pilha-de-chamadas-em-acao"}},[a._v("#")]),a._v(" A pilha de chamadas em ação")]),a._v(" "),s("p",[a._v("Vamos examinar mais detalhadamente como a pilha de chamadas funciona. Aqui está a sequência de etapas que ocorre quando uma função é chamada:")]),a._v(" "),s("ul",[s("li",[a._v("O programa encontra uma chamada de função.")]),a._v(" "),s("li",[a._v("Um quadro de pilha é construído e empurrado na pilha. O quadro da pilha consiste em:")]),a._v(" "),s("li",[a._v("O endereço da instrução além da chamada da função (chamado endereço de retorno). É assim que a CPU se lembra para onde retornar após a saída da função chamada.")]),a._v(" "),s("li",[a._v("Todos os argumentos da função.")]),a._v(" "),s("li",[a._v("Memória para quaisquer variáveis ​​locais.")]),a._v(" "),s("li",[a._v("Cópias salvas de quaisquer registros modificados pela função que precisam ser restauradas quando a função retornar")]),a._v(" "),s("li",[a._v("A CPU pula para o ponto inicial da função.")]),a._v(" "),s("li",[a._v("As instruções dentro da função começam a ser executadas.")])]),a._v(" "),s("p",[a._v("Quando a função termina, ocorrem as seguintes etapas:")]),a._v(" "),s("ul",[s("li",[a._v("Os registros são restaurados da pilha de chamadas")]),a._v(" "),s("li",[a._v("O quadro da pilha é retirado da pilha. Isso libera a memória para todas as variáveis ​​e argumentos locais.")]),a._v(" "),s("li",[a._v("O valor de retorno é tratado.")]),a._v(" "),s("li",[a._v("A CPU retoma a execução no endereço de retorno.")]),a._v(" "),s("li",[a._v("Os valores de retorno podem ser manipulados de várias maneiras diferentes, dependendo da arquitetura do computador. Algumas arquiteturas incluem o valor de retorno como parte do quadro da pilha. Outros usam registradores de CPU.")])]),a._v(" "),s("p",[a._v("Normalmente, não é importante conhecer todos os detalhes sobre como a pilha de chamadas funciona. No entanto, o entendimento de que as funções são efetivamente colocadas na pilha quando são chamadas e ativadas quando retornam fornece os fundamentos necessários para entender a recursão, além de alguns outros conceitos úteis na depuração.")]),a._v(" "),s("p",[a._v("Uma observação técnica: em algumas arquiteturas, a pilha de chamadas cresce para longe do endereço de memória 0. Em outras, cresce para o endereço de memória 0. Como conseqüência, os novos quadros de pilha enviados podem ter um endereço de memória maior ou menor que os anteriores.")]),a._v(" "),s("p",[a._v("Exemplo:")]),a._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("div",{staticClass:"highlight-lines"},[s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br")]),s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// b")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// foo is popped off the call stack here")]),a._v("\n \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// a")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// a função foo foi chamada no push() para a pilha")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// c")]),a._v("\n \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("Estouro de pilha(Não é piada com o site. juro.)")]),a._v(" "),s("p",[a._v("A pilha tem um tamanho limitado e, consequentemente, pode conter apenas uma quantidade limitada de informações. No Windows, o tamanho padrão da pilha é de 1 MB. Em algumas máquinas unix, pode ter até 8 MB. Se o programa tentar colocar muitas informações na pilha, resultará um excesso de pilha. O estouro de pilha acontece quando toda a memória da pilha foi alocada - nesse caso, alocações adicionais começam a transbordar para outras seções da memória.")]),a._v(" "),s("p",[a._v("O estouro de pilha geralmente é o resultado da alocação de muitas variáveis na pilha e / ou de muitas chamadas de funções aninhadas (onde a função A chama a função B chama a função C chama a função D etc ...) Nos sistemas operacionais modernos, o excesso da pilha geralmente faça com que seu sistema operacional emita uma violação de acesso e encerre o programa.")]),a._v(" "),s("p",[a._v("Aqui está um exemplo de programa que provavelmente causará um estouro de pilha. Você pode executá-lo em seu sistema e assisti-lo travar:")]),a._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("div",{staticClass:"highlight-lines"},[s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br")]),s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[a._v("#"),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[a._v("include")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("<iostream>")])]),a._v("\n \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" stack"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10000000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    std"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"He4rt Developers"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<<")]),a._v(" std"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("A classe "),s("code",[a._v("std::vector")]),a._v(" faz muito bem do uso da pilha, recomendado a se utilizar em vés do vetor normal, assim como a classe "),s("code",[a._v("std::array")])])])}),[],!1,null,null,null);e.default=t.exports}}]);